<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ include file="MetricsIncludes.tt" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System" #>
<#@ output extension=".cs" #>

/*
 * This file is part of Project Hybrasyl.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the Affero General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * without ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the Affero General Public License
 * for more details.
 *
 * You should have received a copy of the Affero General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * (C) 2020 ERISCO, LLC 
 *
 * For contributors and individual authors please refer to CONTRIBUTORS.MD.
 * 
 */

using System;
using System.Collections.Generic;
using App.Metrics;
using App.Metrics.Meter;
using App.Metrics.Timer;
using App.Metrics.Gauge;

// THIS FILE IS AUTOGENERATED. CHANGES WILL NOT BE SAVED OR REFLECTED.
// Please look at the T4 template "metricsregistry.tt".

namespace Hybrasyl;

public static class HybrasylMetricsRegistry
{
    public static Dictionary<int, TimerOptions> ControlMessageTimerIndex = new Dictionary<int, TimerOptions>()
{
<# for (var x = 0; x <= 16; x++)
  {
    if (Enum.IsDefined(typeof(ControlOpcodes), (int) x))
    {
#>
       {<#= (byte) x #>, ControlMessage_<#= Enum.GetName(typeof(ControlOpcodes), (int) x) #>},
<# 
   }
   else
   {
#>
       {<#= (byte) x #>, null},
<#

   }
}
#>
    };

    public static Dictionary<byte, TimerOptions> OpcodeTimerIndex = new Dictionary<byte, TimerOptions>()
    {
<# for (var x = 0; x <= 255; x++)
{
  if (Enum.IsDefined(typeof(ClientOpcode), (byte) x))
  {
#>
       {<#= (byte) x #>, Opcode_<#= Enum.GetName(typeof(ClientOpcode), (byte) x) #>},
<# 
   }
   else
   {
#>
       {<#= (byte) x #>, null},
<#

   }
}
#>
    };

    public static MeterOptions ExceptionMeter => new MeterOptions
    {
        Name = "Exception Rate",
        MeasurementUnit = Unit.Errors
    };

    public static GaugeOptions QueueDepth => new GaugeOptions
    {
        Name = "Queue Depth (Opcodes)",
        MeasurementUnit = Unit.Requests
    };

    public static GaugeOptions ControlQueueDepth => new GaugeOptions
    {
        Name = "Queue Depth (Control Messages)",
        MeasurementUnit = Unit.Requests
    };

<# 
  foreach (var co in Enum.GetNames(typeof(ClientOpcode)))
  {
#>
    public static TimerOptions Opcode_<#= co #> => new TimerOptions
    {
        Name = "<#= co #> Packet",
        MeasurementUnit = Unit.Requests,
        DurationUnit = TimeUnit.Milliseconds,
        RateUnit = TimeUnit.Milliseconds,
    };

<#
   }   
#>

<# 
  foreach (var cmo in Enum.GetNames(typeof(ControlOpcodes)))
  {
#>

    public static TimerOptions ControlMessage_<#= cmo #> => new TimerOptions
    {
        Name = "<#= cmo #> Control Message",
        MeasurementUnit = Unit.Requests,
        DurationUnit = TimeUnit.Milliseconds,
        RateUnit = TimeUnit.Milliseconds,
    };
<#
   }   
#>
}
